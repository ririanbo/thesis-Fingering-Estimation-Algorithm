## 前提

* https://github.com/Tsung-Ping/Violin-Fingering-Generation

* {ピッチ番号}、[各弦上の位置番号 : G, D, A, E]で区別
* ピッチ : 55～100まで
* 一つの弦で押さえられる位置は0～24の25箇所  
  （開放弦含む）
* 幹音：白鍵の音、派生音：黒鍵の音

## ピッチ早見表

* 開放弦{G, D, A, E} = {55, 62, 69, 76}

* 1st ポジション
  * 弦 : {開放, 指1, 指2, 指3, 指4}
  * G : {55, 57, 59, 60, 62}
  * D : {62, 64, 65, 67, 69}
  * A : {69, 71, 72, 74, 76}
  * E : {76, 77, 79, 81, 83}

* 2nd ポジション
  * 弦 : {1, 2, 3, 4}
  * G : {59, 60, 62, 64}
  * D : {65, 67, 69, 71}
  * A : {72, 74, 76, 77}
  * E : {79, 81, 83, 84}

* 3rd ポジション
  * 弦 : {1, 2, 3, 4}
  * G : {60, 62, 64, 65}
  * D : {67, 69, 71, 72}
  * A : {74, 76, 77, 79}
  * E : {81, 83, 84, 86}

## 弦位置との対応
* 一つの弦で押さえられる位置は0～24の25箇所  
  （開放弦含む）
* (各ピッチ) - (開放弦ピッチ)で、弦上の位置が分かる
  * {83, } - {55, 62, 69, 76} = [28, 21, 14, 7]
  * {G, D, A, E} = [__, 21, 14, 7]
* 弦のポジションごとの位置  
  * 弦 = (1st, 2nd, 3rd, 4th, ...., )
  * G = [0, 2, 4, 5, 7, 9, 10, 12, 14, 16, 17, 19, 21]
  * D = [0, 2, 3, 5, 7, 9, 10, 12, 14, 15, 17, 19, 21]
  * A = [0, 2, 3, 5, 7, 8, 10, 12, 14, 15, 17, 19, 20]
  * E = [0, 2, 3, 5, 7, 8, 10, 12, 13, 15, 17, 19, 20]

    * 1st ポジション
      * G = [0, 2, 4, 5, 7]
      * D = [0, 2, 3, 5, 7]
      * A = [0, 2, 3, 5, 7]
      * E = [0, 2, 3, 5, 7]

    * 2nd ポジション
      * G = [4, 5, 7, 9]
      * D = [3, 5, 7, 9]
      * A = [3, 5, 7, 8]
      * E = [3, 5, 7, 8]
      
    * 3rd ポジション
      * G = [5, 7, 9, 10]
      * D = [5, 7, 9, 10]
      * A = [5, 7, 8, 10]
      * E = [5, 7, 8, 10]

    * 前から4つずつ切り分けているだけ
    
    * 10th
      * G = [16, 17, 19, 21]
      * D = [15, 17, 19, 21]
      * A = [15, 17, 19, 20]
      * E = [15, 17, 19, 20]

  * ポジション内の各指の守備範囲
    * （第n position）→ n_position[線][0] + (1-2, 2-4, 3-6, 4-7) 
    * 2nd ポジションのG線の場合
      * 2_position[G][0] = 4
      * → (fin_1, fin_2, fin_3, fin_4) = (5-6, 7-8, 9-10,10, )




## 重音の運指決定法
重音 : {64, 72} の運指決定を例に解説  
<br>
* 重音の全ての音に対し、可能な弦上の位置を把握
  * {64, } - {55, 62, 69, 76} = [9, 2, __, __]
  * {72, } - {55, 62, 69, 76} = [17, 10, 3, __]
    * データ構造：{'曲名': }
* その結果を組み合わせ、重音の押す位置を数通りに絞り込み
  * [G, D, A, E] = [9, 10, __, __], [__, 2, 3, __] 
    * 手で同時に押さえられる範囲は[7 :]（開放弦除く）
    * 一弦飛ばし、同じ弦選択はできない
* 各候補に対し、ポジションの決定
  * 弦のポジションごとの位置と照らし合わせて候補だし
  * [9, 10, __, __] -> 3rd, 4th, 5th
  * [__, 2, 3, __]  -> 1st

* 前のポジション、指番号からポジションを1つに決定
  * 左手の移動をなるべく小さくする（ポジション移動最小化）
  * 右手の移動を小さくする（移弦最小化）
  * （案）連続した最大8個の重音ごとに考えて、全体で移動が最小になるように各ポジションをキメる（DP?）


## データ構造

* {'曲名': [sound_num, pitch, height_g, height_d, height_a, height_e]}  
* （例）
  * grade_3_b.csv  
[0, 55, 0, -1, -1, -1]  
[0, 64, 9, 2, -1, -1]  
[1, 60, 5, -1, -1, -1]  
[1, 64, 9, 2, -1, -1]  
...


## 実装で躓いた部分

* どのように音を走査したら重音ごとに運指の組み合わせを考えやすい？
* （仮説）
  * 1曲ごとにforループするする
  * 1番目の要素が変わるまでTMP配列にappendする
  * 出力：[sound_num, g, d, a, e]
  * 重音の音の順番を数通りにシャッフルすることで、小さい音から低い弦を割り当ててしまう拘束を解くことが出来る！！
  * ↑だけではやはり小さい弦から割り当てることに変わりはないため、大きい弦から割り当てるパターンも別で用意する必要があった
  * pitch:75 (D5^)は、運指3,4の両方あり得るがどう決める？
  * 



## 押さえる弦、位置の最終決定
* narrow_choice関数により、各重音に対して演奏可能な選択肢はそろった
* その選択肢からどの観点で最適な運指を1つに決定するか（感性による）
  * 一番低いポジションを選択する（簡単）...select_low_position
    * （実装）弦上の最高位置が一番低い運指を選択する
  * 前のポジションから一番近いポジション運指を選択する（ちょいダル）...select_changeless
    * 部分最適となる
    * ある部分でいきなり大きな移動が起こるのでは？
    * （実装）各重音ごとにポジションという変数を新たに導入
  * N小節を通してポジション移動が最小になるように運指を選択
    * Nをどう選択する？
    * 計算量が大きくなる懸念？


## 決定した位置に対する指の最終決定
* 運指決定手順final
  * どの弦のどの位置で音を出すか決定
  * ポジションの決定
    * 最低位置と最高位置の間隔(width)によって選択肢が変わってくるのでは？
      * width = (4, 5, 6)...fin = [1, 4] (最低音, 最高音)
      * width = (3, 4)...fin = [1, 3], [2, 4]
      * width = (1, 2)...fin = [1, 2], [2, 3], [3, 4]
      * width = (0)(単音)...fin = [1],[2],[3],[4]
      * 待てよ、ポジションごとの幹音の位置よりも、指に対して守備範囲決まってない？
        * （1st position）→ (fin_1, fin_2, fin_3, fin_4) = (1-2, 3-4, 5-6, 6, 7)
        * （第n position）→ n_position[線][0] + (1-2, 3-4, 5-6, 6, 7)
        * でも、元のやり方でも最適なの出てるっぽい---出てなかった！！！
        * 上に変えるべき
  * 指の決定
    * 隣り合う弦なら、同じ指で2弦まで押さえられる
  * ということは、指を決めたらポジションも勝手に決まるのでは？
  * 指・ポジションの決定を同時にするべき
* 最低音（0除く）を1で弾く、2で弾く、3で弾く、4で弾く



## 運指最終決定アルゴリズム
* 各径路に対して得点付け（ペナルティ付与）、
  * 評価関数
    * ポジションの低さ
      * 1st
    * 特定のポジション（1st, 3rd等）を多く使えているか
    * 前後の手の動きの距離の大きさ
    * 開放弦を使っているか


* 最終関数+加点要素
  * evaluate_position
    * 13 - ポジション番号
    * 1st, 3rdポジション
      * 0~15点
      * {1st : 12+3, 2nd : 11, 3rd : 10+3, 4th : 9, ..., 13th : 0}
  * evaluate_left_hand_movement
    * ポジションの移動距離 * (-2)
      * -13~0点
  * evaluate_right_hand_movement
    * (3 - 移弦の移動距離) * 2 
      * 弦位置：[0, 0.5, 1, 1.5, 2, 2.5, 3]
      * 0~6点
  * evaluate_finger
    * 開放弦
    * 同じ指を2回以上使っていたらそのたびに-10点


* 各径路について、一番得点が低いものを選択




## 価値関数の評価項目
* ポジションの高さ:p
  * (13-p)^2/2
    * [-1, 72, 60.5, 50, 40.5, 32, 24.5, 18, 12.5, 8, 4.5, 2, 0.5]
  * 奇数ポジションの優遇
    * [-1, 72, 60, 66, 40, 53, 24, 39, 12, 25, 4, 14, 0]
  * 等間隔
    * [-1, 110, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 0]

* ポジション移動距離
  * 移動距離 * (-5)
    * [0, -5, -10, -15, -20, -25, -30, -35, -40, -45, -50]
* 移弦距離 [0, 0.5, 1, 1.5, 2, 2.5, 3]
  * 移弦距離 * (-3)
    * [0, -1.5, -3, -4.5, -6, -7.5, -9]
* 定石の指位置
  * 定石の指*5
* 単音フラジオレット
  * 10
* 同じ指の同時使用
  * 1本につき-10
* 特別なポジション
  * 1st：+10
  * 3ed：+5
* 開放弦
  * 初心者
    * +10






<br>
<br>
<br>
<br>

















